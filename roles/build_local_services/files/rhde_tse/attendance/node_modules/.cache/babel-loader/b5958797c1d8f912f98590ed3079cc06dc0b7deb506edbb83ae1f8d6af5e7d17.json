{"ast":null,"code":"var parseInt64 = require('pg-int8');\nvar parseBits = function (data, bits, offset, invert, callback) {\n  offset = offset || 0;\n  invert = invert || false;\n  callback = callback || function (lastValue, newValue, bits) {\n    return lastValue * Math.pow(2, bits) + newValue;\n  };\n  var offsetBytes = offset >> 3;\n  var inv = function (value) {\n    if (invert) {\n      return ~value & 0xff;\n    }\n    return value;\n  };\n\n  // read first (maybe partial) byte\n  var mask = 0xff;\n  var firstBits = 8 - offset % 8;\n  if (bits < firstBits) {\n    mask = 0xff << 8 - bits & 0xff;\n    firstBits = bits;\n  }\n  if (offset) {\n    mask = mask >> offset % 8;\n  }\n  var result = 0;\n  if (offset % 8 + bits >= 8) {\n    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);\n  }\n\n  // read bytes\n  var bytes = bits + offset >> 3;\n  for (var i = offsetBytes + 1; i < bytes; i++) {\n    result = callback(result, inv(data[i]), 8);\n  }\n\n  // bits to read, that are not a complete byte\n  var lastBits = (bits + offset) % 8;\n  if (lastBits > 0) {\n    result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);\n  }\n  return result;\n};\nvar parseFloatFromBits = function (data, precisionBits, exponentBits) {\n  var bias = Math.pow(2, exponentBits - 1) - 1;\n  var sign = parseBits(data, 1);\n  var exponent = parseBits(data, exponentBits, 1);\n  if (exponent === 0) {\n    return 0;\n  }\n\n  // parse mantissa\n  var precisionBitsCounter = 1;\n  var parsePrecisionBits = function (lastValue, newValue, bits) {\n    if (lastValue === 0) {\n      lastValue = 1;\n    }\n    for (var i = 1; i <= bits; i++) {\n      precisionBitsCounter /= 2;\n      if ((newValue & 0x1 << bits - i) > 0) {\n        lastValue += precisionBitsCounter;\n      }\n    }\n    return lastValue;\n  };\n  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);\n\n  // special cases\n  if (exponent == Math.pow(2, exponentBits + 1) - 1) {\n    if (mantissa === 0) {\n      return sign === 0 ? Infinity : -Infinity;\n    }\n    return NaN;\n  }\n\n  // normale number\n  return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;\n};\nvar parseInt16 = function (value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 15, 1, true) + 1);\n  }\n  return parseBits(value, 15, 1);\n};\nvar parseInt32 = function (value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 31, 1, true) + 1);\n  }\n  return parseBits(value, 31, 1);\n};\nvar parseFloat32 = function (value) {\n  return parseFloatFromBits(value, 23, 8);\n};\nvar parseFloat64 = function (value) {\n  return parseFloatFromBits(value, 52, 11);\n};\nvar parseNumeric = function (value) {\n  var sign = parseBits(value, 16, 32);\n  if (sign == 0xc000) {\n    return NaN;\n  }\n  var weight = Math.pow(10000, parseBits(value, 16, 16));\n  var result = 0;\n  var digits = [];\n  var ndigits = parseBits(value, 16);\n  for (var i = 0; i < ndigits; i++) {\n    result += parseBits(value, 16, 64 + 16 * i) * weight;\n    weight /= 10000;\n  }\n  var scale = Math.pow(10, parseBits(value, 16, 48));\n  return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;\n};\nvar parseDate = function (isUTC, value) {\n  var sign = parseBits(value, 1);\n  var rawValue = parseBits(value, 63, 1);\n\n  // discard usecs and shift from 2000 to 1970\n  var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);\n  if (!isUTC) {\n    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);\n  }\n\n  // add microseconds to the date\n  result.usec = rawValue % 1000;\n  result.getMicroSeconds = function () {\n    return this.usec;\n  };\n  result.setMicroSeconds = function (value) {\n    this.usec = value;\n  };\n  result.getUTCMicroSeconds = function () {\n    return this.usec;\n  };\n  return result;\n};\nvar parseArray = function (value) {\n  var dim = parseBits(value, 32);\n  var flags = parseBits(value, 32, 32);\n  var elementType = parseBits(value, 32, 64);\n  var offset = 96;\n  var dims = [];\n  for (var i = 0; i < dim; i++) {\n    // parse dimension\n    dims[i] = parseBits(value, 32, offset);\n    offset += 32;\n\n    // ignore lower bounds\n    offset += 32;\n  }\n  var parseElement = function (elementType) {\n    // parse content length\n    var length = parseBits(value, 32, offset);\n    offset += 32;\n\n    // parse null values\n    if (length == 0xffffffff) {\n      return null;\n    }\n    var result;\n    if (elementType == 0x17 || elementType == 0x14) {\n      // int/bigint\n      result = parseBits(value, length * 8, offset);\n      offset += length * 8;\n      return result;\n    } else if (elementType == 0x19) {\n      // string\n      result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);\n      return result;\n    } else {\n      console.log(\"ERROR: ElementType not implemented: \" + elementType);\n    }\n  };\n  var parse = function (dimension, elementType) {\n    var array = [];\n    var i;\n    if (dimension.length > 1) {\n      var count = dimension.shift();\n      for (i = 0; i < count; i++) {\n        array[i] = parse(dimension, elementType);\n      }\n      dimension.unshift(count);\n    } else {\n      for (i = 0; i < dimension[0]; i++) {\n        array[i] = parseElement(elementType);\n      }\n    }\n    return array;\n  };\n  return parse(dims, elementType);\n};\nvar parseText = function (value) {\n  return value.toString('utf8');\n};\nvar parseBool = function (value) {\n  if (value === null) return null;\n  return parseBits(value, 8) > 0;\n};\nvar init = function (register) {\n  register(20, parseInt64);\n  register(21, parseInt16);\n  register(23, parseInt32);\n  register(26, parseInt32);\n  register(1700, parseNumeric);\n  register(700, parseFloat32);\n  register(701, parseFloat64);\n  register(16, parseBool);\n  register(1114, parseDate.bind(null, false));\n  register(1184, parseDate.bind(null, true));\n  register(1000, parseArray);\n  register(1007, parseArray);\n  register(1016, parseArray);\n  register(1008, parseArray);\n  register(1009, parseArray);\n  register(25, parseText);\n};\nmodule.exports = {\n  init: init\n};","map":{"version":3,"names":["parseInt64","require","parseBits","data","bits","offset","invert","callback","lastValue","newValue","Math","pow","offsetBytes","inv","value","mask","firstBits","result","bytes","i","lastBits","parseFloatFromBits","precisionBits","exponentBits","bias","sign","exponent","precisionBitsCounter","parsePrecisionBits","mantissa","Infinity","NaN","parseInt16","parseInt32","parseFloat32","parseFloat64","parseNumeric","weight","digits","ndigits","scale","round","parseDate","isUTC","rawValue","Date","setTime","getTime","getTimezoneOffset","usec","getMicroSeconds","setMicroSeconds","getUTCMicroSeconds","parseArray","dim","flags","elementType","dims","parseElement","length","toString","encoding","console","log","parse","dimension","array","count","shift","unshift","parseText","parseBool","init","register","bind","module","exports"],"sources":["C:/work/Demo/device-edge-workshops/roles/build_local_services/files/rhde_tse/attendance/node_modules/pg-types/lib/binaryParsers.js"],"sourcesContent":["var parseInt64 = require('pg-int8');\n\nvar parseBits = function(data, bits, offset, invert, callback) {\n  offset = offset || 0;\n  invert = invert || false;\n  callback = callback || function(lastValue, newValue, bits) { return (lastValue * Math.pow(2, bits)) + newValue; };\n  var offsetBytes = offset >> 3;\n\n  var inv = function(value) {\n    if (invert) {\n      return ~value & 0xff;\n    }\n\n    return value;\n  };\n\n  // read first (maybe partial) byte\n  var mask = 0xff;\n  var firstBits = 8 - (offset % 8);\n  if (bits < firstBits) {\n    mask = (0xff << (8 - bits)) & 0xff;\n    firstBits = bits;\n  }\n\n  if (offset) {\n    mask = mask >> (offset % 8);\n  }\n\n  var result = 0;\n  if ((offset % 8) + bits >= 8) {\n    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);\n  }\n\n  // read bytes\n  var bytes = (bits + offset) >> 3;\n  for (var i = offsetBytes + 1; i < bytes; i++) {\n    result = callback(result, inv(data[i]), 8);\n  }\n\n  // bits to read, that are not a complete byte\n  var lastBits = (bits + offset) % 8;\n  if (lastBits > 0) {\n    result = callback(result, inv(data[bytes]) >> (8 - lastBits), lastBits);\n  }\n\n  return result;\n};\n\nvar parseFloatFromBits = function(data, precisionBits, exponentBits) {\n  var bias = Math.pow(2, exponentBits - 1) - 1;\n  var sign = parseBits(data, 1);\n  var exponent = parseBits(data, exponentBits, 1);\n\n  if (exponent === 0) {\n    return 0;\n  }\n\n  // parse mantissa\n  var precisionBitsCounter = 1;\n  var parsePrecisionBits = function(lastValue, newValue, bits) {\n    if (lastValue === 0) {\n      lastValue = 1;\n    }\n\n    for (var i = 1; i <= bits; i++) {\n      precisionBitsCounter /= 2;\n      if ((newValue & (0x1 << (bits - i))) > 0) {\n        lastValue += precisionBitsCounter;\n      }\n    }\n\n    return lastValue;\n  };\n\n  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);\n\n  // special cases\n  if (exponent == (Math.pow(2, exponentBits + 1) - 1)) {\n    if (mantissa === 0) {\n      return (sign === 0) ? Infinity : -Infinity;\n    }\n\n    return NaN;\n  }\n\n  // normale number\n  return ((sign === 0) ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;\n};\n\nvar parseInt16 = function(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 15, 1, true) + 1);\n  }\n\n  return parseBits(value, 15, 1);\n};\n\nvar parseInt32 = function(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 31, 1, true) + 1);\n  }\n\n  return parseBits(value, 31, 1);\n};\n\nvar parseFloat32 = function(value) {\n  return parseFloatFromBits(value, 23, 8);\n};\n\nvar parseFloat64 = function(value) {\n  return parseFloatFromBits(value, 52, 11);\n};\n\nvar parseNumeric = function(value) {\n  var sign = parseBits(value, 16, 32);\n  if (sign == 0xc000) {\n    return NaN;\n  }\n\n  var weight = Math.pow(10000, parseBits(value, 16, 16));\n  var result = 0;\n\n  var digits = [];\n  var ndigits = parseBits(value, 16);\n  for (var i = 0; i < ndigits; i++) {\n    result += parseBits(value, 16, 64 + (16 * i)) * weight;\n    weight /= 10000;\n  }\n\n  var scale = Math.pow(10, parseBits(value, 16, 48));\n  return ((sign === 0) ? 1 : -1) * Math.round(result * scale) / scale;\n};\n\nvar parseDate = function(isUTC, value) {\n  var sign = parseBits(value, 1);\n  var rawValue = parseBits(value, 63, 1);\n\n  // discard usecs and shift from 2000 to 1970\n  var result = new Date((((sign === 0) ? 1 : -1) * rawValue / 1000) + 946684800000);\n\n  if (!isUTC) {\n    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);\n  }\n\n  // add microseconds to the date\n  result.usec = rawValue % 1000;\n  result.getMicroSeconds = function() {\n    return this.usec;\n  };\n  result.setMicroSeconds = function(value) {\n    this.usec = value;\n  };\n  result.getUTCMicroSeconds = function() {\n    return this.usec;\n  };\n\n  return result;\n};\n\nvar parseArray = function(value) {\n  var dim = parseBits(value, 32);\n\n  var flags = parseBits(value, 32, 32);\n  var elementType = parseBits(value, 32, 64);\n\n  var offset = 96;\n  var dims = [];\n  for (var i = 0; i < dim; i++) {\n    // parse dimension\n    dims[i] = parseBits(value, 32, offset);\n    offset += 32;\n\n    // ignore lower bounds\n    offset += 32;\n  }\n\n  var parseElement = function(elementType) {\n    // parse content length\n    var length = parseBits(value, 32, offset);\n    offset += 32;\n\n    // parse null values\n    if (length == 0xffffffff) {\n      return null;\n    }\n\n    var result;\n    if ((elementType == 0x17) || (elementType == 0x14)) {\n      // int/bigint\n      result = parseBits(value, length * 8, offset);\n      offset += length * 8;\n      return result;\n    }\n    else if (elementType == 0x19) {\n      // string\n      result = value.toString(this.encoding, offset >> 3, (offset += (length << 3)) >> 3);\n      return result;\n    }\n    else {\n      console.log(\"ERROR: ElementType not implemented: \" + elementType);\n    }\n  };\n\n  var parse = function(dimension, elementType) {\n    var array = [];\n    var i;\n\n    if (dimension.length > 1) {\n      var count = dimension.shift();\n      for (i = 0; i < count; i++) {\n        array[i] = parse(dimension, elementType);\n      }\n      dimension.unshift(count);\n    }\n    else {\n      for (i = 0; i < dimension[0]; i++) {\n        array[i] = parseElement(elementType);\n      }\n    }\n\n    return array;\n  };\n\n  return parse(dims, elementType);\n};\n\nvar parseText = function(value) {\n  return value.toString('utf8');\n};\n\nvar parseBool = function(value) {\n  if(value === null) return null;\n  return (parseBits(value, 8) > 0);\n};\n\nvar init = function(register) {\n  register(20, parseInt64);\n  register(21, parseInt16);\n  register(23, parseInt32);\n  register(26, parseInt32);\n  register(1700, parseNumeric);\n  register(700, parseFloat32);\n  register(701, parseFloat64);\n  register(16, parseBool);\n  register(1114, parseDate.bind(null, false));\n  register(1184, parseDate.bind(null, true));\n  register(1000, parseArray);\n  register(1007, parseArray);\n  register(1016, parseArray);\n  register(1008, parseArray);\n  register(1009, parseArray);\n  register(25, parseText);\n};\n\nmodule.exports = {\n  init: init\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}