{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\nconst messages_1 = require(\"./messages\");\nconst buffer_reader_1 = require(\"./buffer-reader\");\nconst assert_1 = __importDefault(require(\"assert\"));\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1;\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4;\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nconst emptyBuffer = Buffer.allocUnsafe(0);\nclass Parser {\n  constructor(opts) {\n    this.buffer = emptyBuffer;\n    this.bufferLength = 0;\n    this.bufferOffset = 0;\n    this.reader = new buffer_reader_1.BufferReader();\n    if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\n      throw new Error('Binary mode not supported yet');\n    }\n    this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\n  }\n  parse(buffer, callback) {\n    this.mergeBuffer(buffer);\n    const bufferFullLength = this.bufferOffset + this.bufferLength;\n    let offset = this.bufferOffset;\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = this.buffer[offset];\n      // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n      const fullMessageLength = CODE_LENGTH + length;\n      if (fullMessageLength + offset <= bufferFullLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n        callback(message);\n        offset += fullMessageLength;\n      } else {\n        break;\n      }\n    }\n    if (offset === bufferFullLength) {\n      // No more use for the buffer\n      this.buffer = emptyBuffer;\n      this.bufferLength = 0;\n      this.bufferOffset = 0;\n    } else {\n      // Adjust the cursors of remainingBuffer\n      this.bufferLength = bufferFullLength - offset;\n      this.bufferOffset = offset;\n    }\n  }\n  mergeBuffer(buffer) {\n    if (this.bufferLength > 0) {\n      const newLength = this.bufferLength + buffer.byteLength;\n      const newFullLength = newLength + this.bufferOffset;\n      if (newFullLength > this.buffer.byteLength) {\n        // We can't concat the new buffer with the remaining one\n        let newBuffer;\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n          newBuffer = this.buffer;\n        } else {\n          // Allocate a new larger buffer\n          let newBufferLength = this.buffer.byteLength * 2;\n          while (newLength >= newBufferLength) {\n            newBufferLength *= 2;\n          }\n          newBuffer = Buffer.allocUnsafe(newBufferLength);\n        }\n        // Move the remaining buffer to the new one\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n        this.buffer = newBuffer;\n        this.bufferOffset = 0;\n      }\n      // Concat the new buffer with the remaining one\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n      this.bufferLength = newLength;\n    } else {\n      this.buffer = buffer;\n      this.bufferOffset = 0;\n      this.bufferLength = buffer.byteLength;\n    }\n  }\n  handlePacket(offset, code, length, bytes) {\n    switch (code) {\n      case 50 /* BindComplete */:\n        return messages_1.bindComplete;\n      case 49 /* ParseComplete */:\n        return messages_1.parseComplete;\n      case 51 /* CloseComplete */:\n        return messages_1.closeComplete;\n      case 110 /* NoData */:\n        return messages_1.noData;\n      case 115 /* PortalSuspended */:\n        return messages_1.portalSuspended;\n      case 99 /* CopyDone */:\n        return messages_1.copyDone;\n      case 87 /* ReplicationStart */:\n        return messages_1.replicationStart;\n      case 73 /* EmptyQuery */:\n        return messages_1.emptyQuery;\n      case 68 /* DataRow */:\n        return this.parseDataRowMessage(offset, length, bytes);\n      case 67 /* CommandComplete */:\n        return this.parseCommandCompleteMessage(offset, length, bytes);\n      case 90 /* ReadyForQuery */:\n        return this.parseReadyForQueryMessage(offset, length, bytes);\n      case 65 /* NotificationResponse */:\n        return this.parseNotificationMessage(offset, length, bytes);\n      case 82 /* AuthenticationResponse */:\n        return this.parseAuthenticationResponse(offset, length, bytes);\n      case 83 /* ParameterStatus */:\n        return this.parseParameterStatusMessage(offset, length, bytes);\n      case 75 /* BackendKeyData */:\n        return this.parseBackendKeyData(offset, length, bytes);\n      case 69 /* ErrorMessage */:\n        return this.parseErrorMessage(offset, length, bytes, 'error');\n      case 78 /* NoticeMessage */:\n        return this.parseErrorMessage(offset, length, bytes, 'notice');\n      case 84 /* RowDescriptionMessage */:\n        return this.parseRowDescriptionMessage(offset, length, bytes);\n      case 116 /* ParameterDescriptionMessage */:\n        return this.parseParameterDescriptionMessage(offset, length, bytes);\n      case 71 /* CopyIn */:\n        return this.parseCopyInMessage(offset, length, bytes);\n      case 72 /* CopyOut */:\n        return this.parseCopyOutMessage(offset, length, bytes);\n      case 100 /* CopyData */:\n        return this.parseCopyData(offset, length, bytes);\n      default:\n        assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\n    }\n  }\n  parseReadyForQueryMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const status = this.reader.string(1);\n    return new messages_1.ReadyForQueryMessage(length, status);\n  }\n  parseCommandCompleteMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const text = this.reader.cstring();\n    return new messages_1.CommandCompleteMessage(length, text);\n  }\n  parseCopyData(offset, length, bytes) {\n    const chunk = bytes.slice(offset, offset + (length - 4));\n    return new messages_1.CopyDataMessage(length, chunk);\n  }\n  parseCopyInMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n  }\n  parseCopyOutMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n  }\n  parseCopyMessage(offset, length, bytes, messageName) {\n    this.reader.setBuffer(offset, bytes);\n    const isBinary = this.reader.byte() !== 0;\n    const columnCount = this.reader.int16();\n    const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16();\n    }\n    return message;\n  }\n  parseNotificationMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processId = this.reader.int32();\n    const channel = this.reader.cstring();\n    const payload = this.reader.cstring();\n    return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n  }\n  parseRowDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const message = new messages_1.RowDescriptionMessage(length, fieldCount);\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField();\n    }\n    return message;\n  }\n  parseField() {\n    const name = this.reader.cstring();\n    const tableID = this.reader.int32();\n    const columnID = this.reader.int16();\n    const dataTypeID = this.reader.int32();\n    const dataTypeSize = this.reader.int16();\n    const dataTypeModifier = this.reader.int32();\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n    return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n  }\n  parseParameterDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const parameterCount = this.reader.int16();\n    const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\n    for (let i = 0; i < parameterCount; i++) {\n      message.dataTypeIDs[i] = this.reader.int32();\n    }\n    return message;\n  }\n  parseDataRowMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const fields = new Array(fieldCount);\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32();\n      // a -1 for length means the value of the field is null\n      fields[i] = len === -1 ? null : this.reader.string(len);\n    }\n    return new messages_1.DataRowMessage(length, fields);\n  }\n  parseParameterStatusMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const name = this.reader.cstring();\n    const value = this.reader.cstring();\n    return new messages_1.ParameterStatusMessage(length, name, value);\n  }\n  parseBackendKeyData(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processID = this.reader.int32();\n    const secretKey = this.reader.int32();\n    return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n  }\n  parseAuthenticationResponse(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const code = this.reader.int32();\n    // TODO(bmc): maybe better types here\n    const message = {\n      name: 'authenticationOk',\n      length\n    };\n    switch (code) {\n      case 0:\n        // AuthenticationOk\n        break;\n      case 3:\n        // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = 'authenticationCleartextPassword';\n        }\n        break;\n      case 5:\n        // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = 'authenticationMD5Password';\n          const salt = this.reader.bytes(4);\n          return new messages_1.AuthenticationMD5Password(length, salt);\n        }\n        break;\n      case 10:\n        // AuthenticationSASL\n        message.name = 'authenticationSASL';\n        message.mechanisms = [];\n        let mechanism;\n        do {\n          mechanism = this.reader.cstring();\n          if (mechanism) {\n            message.mechanisms.push(mechanism);\n          }\n        } while (mechanism);\n        break;\n      case 11:\n        // AuthenticationSASLContinue\n        message.name = 'authenticationSASLContinue';\n        message.data = this.reader.string(length - 8);\n        break;\n      case 12:\n        // AuthenticationSASLFinal\n        message.name = 'authenticationSASLFinal';\n        message.data = this.reader.string(length - 8);\n        break;\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code);\n    }\n    return message;\n  }\n  parseErrorMessage(offset, length, bytes, name) {\n    this.reader.setBuffer(offset, bytes);\n    const fields = {};\n    let fieldType = this.reader.string(1);\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring();\n      fieldType = this.reader.string(1);\n    }\n    const messageValue = fields.M;\n    const message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n    message.severity = fields.S;\n    message.code = fields.C;\n    message.detail = fields.D;\n    message.hint = fields.H;\n    message.position = fields.P;\n    message.internalPosition = fields.p;\n    message.internalQuery = fields.q;\n    message.where = fields.W;\n    message.schema = fields.s;\n    message.table = fields.t;\n    message.column = fields.c;\n    message.dataType = fields.d;\n    message.constraint = fields.n;\n    message.file = fields.F;\n    message.line = fields.L;\n    message.routine = fields.R;\n    return message;\n  }\n}\nexports.Parser = Parser;","map":{"version":3,"names":["messages_1","require","buffer_reader_1","assert_1","__importDefault","CODE_LENGTH","LEN_LENGTH","HEADER_LENGTH","emptyBuffer","Buffer","allocUnsafe","Parser","constructor","opts","buffer","bufferLength","bufferOffset","reader","BufferReader","mode","Error","parse","callback","mergeBuffer","bufferFullLength","offset","code","length","readUInt32BE","fullMessageLength","message","handlePacket","newLength","byteLength","newFullLength","newBuffer","newBufferLength","copy","bytes","bindComplete","parseComplete","closeComplete","noData","portalSuspended","copyDone","replicationStart","emptyQuery","parseDataRowMessage","parseCommandCompleteMessage","parseReadyForQueryMessage","parseNotificationMessage","parseAuthenticationResponse","parseParameterStatusMessage","parseBackendKeyData","parseErrorMessage","parseRowDescriptionMessage","parseParameterDescriptionMessage","parseCopyInMessage","parseCopyOutMessage","parseCopyData","default","fail","toString","setBuffer","status","string","ReadyForQueryMessage","text","cstring","CommandCompleteMessage","chunk","slice","CopyDataMessage","parseCopyMessage","messageName","isBinary","byte","columnCount","int16","CopyResponse","i","columnTypes","processId","int32","channel","payload","NotificationResponseMessage","fieldCount","RowDescriptionMessage","fields","parseField","name","tableID","columnID","dataTypeID","dataTypeSize","dataTypeModifier","Field","parameterCount","ParameterDescriptionMessage","dataTypeIDs","Array","len","DataRowMessage","value","ParameterStatusMessage","processID","secretKey","BackendKeyDataMessage","salt","AuthenticationMD5Password","mechanisms","mechanism","push","data","fieldType","messageValue","M","NoticeMessage","DatabaseError","severity","S","C","detail","D","hint","H","position","P","internalPosition","p","internalQuery","q","where","W","schema","s","table","t","column","c","dataType","d","constraint","n","file","F","line","L","routine","R","exports"],"sources":["C:\\work\\Demo\\device-edge-workshops\\roles\\build_local_services\\files\\rhde_tse\\attendance\\node_modules\\pg-protocol\\src\\parser.ts"],"sourcesContent":["import { TransformOptions } from 'stream'\nimport {\n  Mode,\n  bindComplete,\n  parseComplete,\n  closeComplete,\n  noData,\n  portalSuspended,\n  copyDone,\n  replicationStart,\n  emptyQuery,\n  ReadyForQueryMessage,\n  CommandCompleteMessage,\n  CopyDataMessage,\n  CopyResponse,\n  NotificationResponseMessage,\n  RowDescriptionMessage,\n  ParameterDescriptionMessage,\n  Field,\n  DataRowMessage,\n  ParameterStatusMessage,\n  BackendKeyDataMessage,\n  DatabaseError,\n  BackendMessage,\n  MessageName,\n  AuthenticationMD5Password,\n  NoticeMessage,\n} from './messages'\nimport { BufferReader } from './buffer-reader'\nimport assert from 'assert'\n\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4\n\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH\n\nexport type Packet = {\n  code: number\n  packet: Buffer\n}\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\ntype StreamOptions = TransformOptions & {\n  mode: Mode\n}\n\nconst enum MessageCodes {\n  DataRow = 0x44, // D\n  ParseComplete = 0x31, // 1\n  BindComplete = 0x32, // 2\n  CloseComplete = 0x33, // 3\n  CommandComplete = 0x43, // C\n  ReadyForQuery = 0x5a, // Z\n  NoData = 0x6e, // n\n  NotificationResponse = 0x41, // A\n  AuthenticationResponse = 0x52, // R\n  ParameterStatus = 0x53, // S\n  BackendKeyData = 0x4b, // K\n  ErrorMessage = 0x45, // E\n  NoticeMessage = 0x4e, // N\n  RowDescriptionMessage = 0x54, // T\n  ParameterDescriptionMessage = 0x74, // t\n  PortalSuspended = 0x73, // s\n  ReplicationStart = 0x57, // W\n  EmptyQuery = 0x49, // I\n  CopyIn = 0x47, // G\n  CopyOut = 0x48, // H\n  CopyDone = 0x63, // c\n  CopyData = 0x64, // d\n}\n\nexport type MessageCallback = (msg: BackendMessage) => void\n\nexport class Parser {\n  private buffer: Buffer = emptyBuffer\n  private bufferLength: number = 0\n  private bufferOffset: number = 0\n  private reader = new BufferReader()\n  private mode: Mode\n\n  constructor(opts?: StreamOptions) {\n    if (opts?.mode === 'binary') {\n      throw new Error('Binary mode not supported yet')\n    }\n    this.mode = opts?.mode || 'text'\n  }\n\n  public parse(buffer: Buffer, callback: MessageCallback) {\n    this.mergeBuffer(buffer)\n    const bufferFullLength = this.bufferOffset + this.bufferLength\n    let offset = this.bufferOffset\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = this.buffer[offset]\n      // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH)\n      const fullMessageLength = CODE_LENGTH + length\n      if (fullMessageLength + offset <= bufferFullLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer)\n        callback(message)\n        offset += fullMessageLength\n      } else {\n        break\n      }\n    }\n    if (offset === bufferFullLength) {\n      // No more use for the buffer\n      this.buffer = emptyBuffer\n      this.bufferLength = 0\n      this.bufferOffset = 0\n    } else {\n      // Adjust the cursors of remainingBuffer\n      this.bufferLength = bufferFullLength - offset\n      this.bufferOffset = offset\n    }\n  }\n\n  private mergeBuffer(buffer: Buffer): void {\n    if (this.bufferLength > 0) {\n      const newLength = this.bufferLength + buffer.byteLength\n      const newFullLength = newLength + this.bufferOffset\n      if (newFullLength > this.buffer.byteLength) {\n        // We can't concat the new buffer with the remaining one\n        let newBuffer: Buffer\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n          newBuffer = this.buffer\n        } else {\n          // Allocate a new larger buffer\n          let newBufferLength = this.buffer.byteLength * 2\n          while (newLength >= newBufferLength) {\n            newBufferLength *= 2\n          }\n          newBuffer = Buffer.allocUnsafe(newBufferLength)\n        }\n        // Move the remaining buffer to the new one\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength)\n        this.buffer = newBuffer\n        this.bufferOffset = 0\n      }\n      // Concat the new buffer with the remaining one\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength)\n      this.bufferLength = newLength\n    } else {\n      this.buffer = buffer\n      this.bufferOffset = 0\n      this.bufferLength = buffer.byteLength\n    }\n  }\n\n  private handlePacket(offset: number, code: number, length: number, bytes: Buffer): BackendMessage {\n    switch (code) {\n      case MessageCodes.BindComplete:\n        return bindComplete\n      case MessageCodes.ParseComplete:\n        return parseComplete\n      case MessageCodes.CloseComplete:\n        return closeComplete\n      case MessageCodes.NoData:\n        return noData\n      case MessageCodes.PortalSuspended:\n        return portalSuspended\n      case MessageCodes.CopyDone:\n        return copyDone\n      case MessageCodes.ReplicationStart:\n        return replicationStart\n      case MessageCodes.EmptyQuery:\n        return emptyQuery\n      case MessageCodes.DataRow:\n        return this.parseDataRowMessage(offset, length, bytes)\n      case MessageCodes.CommandComplete:\n        return this.parseCommandCompleteMessage(offset, length, bytes)\n      case MessageCodes.ReadyForQuery:\n        return this.parseReadyForQueryMessage(offset, length, bytes)\n      case MessageCodes.NotificationResponse:\n        return this.parseNotificationMessage(offset, length, bytes)\n      case MessageCodes.AuthenticationResponse:\n        return this.parseAuthenticationResponse(offset, length, bytes)\n      case MessageCodes.ParameterStatus:\n        return this.parseParameterStatusMessage(offset, length, bytes)\n      case MessageCodes.BackendKeyData:\n        return this.parseBackendKeyData(offset, length, bytes)\n      case MessageCodes.ErrorMessage:\n        return this.parseErrorMessage(offset, length, bytes, 'error')\n      case MessageCodes.NoticeMessage:\n        return this.parseErrorMessage(offset, length, bytes, 'notice')\n      case MessageCodes.RowDescriptionMessage:\n        return this.parseRowDescriptionMessage(offset, length, bytes)\n      case MessageCodes.ParameterDescriptionMessage:\n        return this.parseParameterDescriptionMessage(offset, length, bytes)\n      case MessageCodes.CopyIn:\n        return this.parseCopyInMessage(offset, length, bytes)\n      case MessageCodes.CopyOut:\n        return this.parseCopyOutMessage(offset, length, bytes)\n      case MessageCodes.CopyData:\n        return this.parseCopyData(offset, length, bytes)\n      default:\n        assert.fail(`unknown message code: ${code.toString(16)}`)\n    }\n  }\n\n  private parseReadyForQueryMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const status = this.reader.string(1)\n    return new ReadyForQueryMessage(length, status)\n  }\n\n  private parseCommandCompleteMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const text = this.reader.cstring()\n    return new CommandCompleteMessage(length, text)\n  }\n\n  private parseCopyData(offset: number, length: number, bytes: Buffer) {\n    const chunk = bytes.slice(offset, offset + (length - 4))\n    return new CopyDataMessage(length, chunk)\n  }\n\n  private parseCopyInMessage(offset: number, length: number, bytes: Buffer) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse')\n  }\n\n  private parseCopyOutMessage(offset: number, length: number, bytes: Buffer) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse')\n  }\n\n  private parseCopyMessage(offset: number, length: number, bytes: Buffer, messageName: MessageName) {\n    this.reader.setBuffer(offset, bytes)\n    const isBinary = this.reader.byte() !== 0\n    const columnCount = this.reader.int16()\n    const message = new CopyResponse(length, messageName, isBinary, columnCount)\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16()\n    }\n    return message\n  }\n\n  private parseNotificationMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const processId = this.reader.int32()\n    const channel = this.reader.cstring()\n    const payload = this.reader.cstring()\n    return new NotificationResponseMessage(length, processId, channel, payload)\n  }\n\n  private parseRowDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const fieldCount = this.reader.int16()\n    const message = new RowDescriptionMessage(length, fieldCount)\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField()\n    }\n    return message\n  }\n\n  private parseField(): Field {\n    const name = this.reader.cstring()\n    const tableID = this.reader.int32()\n    const columnID = this.reader.int16()\n    const dataTypeID = this.reader.int32()\n    const dataTypeSize = this.reader.int16()\n    const dataTypeModifier = this.reader.int32()\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary'\n    return new Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode)\n  }\n\n  private parseParameterDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const parameterCount = this.reader.int16()\n    const message = new ParameterDescriptionMessage(length, parameterCount)\n    for (let i = 0; i < parameterCount; i++) {\n      message.dataTypeIDs[i] = this.reader.int32()\n    }\n    return message\n  }\n\n  private parseDataRowMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const fieldCount = this.reader.int16()\n    const fields: any[] = new Array(fieldCount)\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32()\n      // a -1 for length means the value of the field is null\n      fields[i] = len === -1 ? null : this.reader.string(len)\n    }\n    return new DataRowMessage(length, fields)\n  }\n\n  private parseParameterStatusMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const name = this.reader.cstring()\n    const value = this.reader.cstring()\n    return new ParameterStatusMessage(length, name, value)\n  }\n\n  private parseBackendKeyData(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const processID = this.reader.int32()\n    const secretKey = this.reader.int32()\n    return new BackendKeyDataMessage(length, processID, secretKey)\n  }\n\n  public parseAuthenticationResponse(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const code = this.reader.int32()\n    // TODO(bmc): maybe better types here\n    const message: BackendMessage & any = {\n      name: 'authenticationOk',\n      length,\n    }\n\n    switch (code) {\n      case 0: // AuthenticationOk\n        break\n      case 3: // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = 'authenticationCleartextPassword'\n        }\n        break\n      case 5: // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = 'authenticationMD5Password'\n          const salt = this.reader.bytes(4)\n          return new AuthenticationMD5Password(length, salt)\n        }\n        break\n      case 10: // AuthenticationSASL\n        message.name = 'authenticationSASL'\n        message.mechanisms = []\n        let mechanism: string\n        do {\n          mechanism = this.reader.cstring()\n\n          if (mechanism) {\n            message.mechanisms.push(mechanism)\n          }\n        } while (mechanism)\n        break\n      case 11: // AuthenticationSASLContinue\n        message.name = 'authenticationSASLContinue'\n        message.data = this.reader.string(length - 8)\n        break\n      case 12: // AuthenticationSASLFinal\n        message.name = 'authenticationSASLFinal'\n        message.data = this.reader.string(length - 8)\n        break\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code)\n    }\n    return message\n  }\n\n  private parseErrorMessage(offset: number, length: number, bytes: Buffer, name: MessageName) {\n    this.reader.setBuffer(offset, bytes)\n    const fields: Record<string, string> = {}\n    let fieldType = this.reader.string(1)\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring()\n      fieldType = this.reader.string(1)\n    }\n\n    const messageValue = fields.M\n\n    const message =\n      name === 'notice' ? new NoticeMessage(length, messageValue) : new DatabaseError(messageValue, length, name)\n\n    message.severity = fields.S\n    message.code = fields.C\n    message.detail = fields.D\n    message.hint = fields.H\n    message.position = fields.P\n    message.internalPosition = fields.p\n    message.internalQuery = fields.q\n    message.where = fields.W\n    message.schema = fields.s\n    message.table = fields.t\n    message.column = fields.c\n    message.dataType = fields.d\n    message.constraint = fields.n\n    message.file = fields.F\n    message.line = fields.L\n    message.routine = fields.R\n    return message\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}