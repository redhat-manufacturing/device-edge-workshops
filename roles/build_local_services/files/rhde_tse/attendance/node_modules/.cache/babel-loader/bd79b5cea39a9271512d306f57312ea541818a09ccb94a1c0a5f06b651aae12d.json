{"ast":null,"code":"import { interpolate, defaultOffset } from '@motionone/utils';\nimport { calcInset } from './inset.es.js';\nimport { ScrollOffset } from './presets.es.js';\nimport { resolveOffset } from './offset.es.js';\nconst point = {\n  x: 0,\n  y: 0\n};\nfunction resolveOffsets(container, info, options) {\n  let {\n    offset: offsetDefinition = ScrollOffset.All\n  } = options;\n  const {\n    target = container,\n    axis = \"y\"\n  } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n  const targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n  for (let i = 0; i < numOffsets; i++) {\n    const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i] = offset;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n  if (hasChanged) {\n    info[axis].interpolate = interpolate(defaultOffset(numOffsets), info[axis].offset);\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\nexport { resolveOffsets };","map":{"version":3,"names":["interpolate","defaultOffset","calcInset","ScrollOffset","resolveOffset","point","x","y","resolveOffsets","container","info","options","offset","offsetDefinition","All","target","axis","lengthLabel","inset","targetSize","width","scrollWidth","height","scrollHeight","clientWidth","clientHeight","containerSize","length","hasChanged","numOffsets","i","interpolatorOffsets","progress","current"],"sources":["C:/work/Demo/device-edge-workshops/roles/build_local_services/files/rhde_tse/attendance/node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.es.js"],"sourcesContent":["import { interpolate, defaultOffset } from '@motionone/utils';\nimport { calcInset } from './inset.es.js';\nimport { ScrollOffset } from './presets.es.js';\nimport { resolveOffset } from './offset.es.js';\n\nconst point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : { width: target.clientWidth, height: target.clientHeight };\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(defaultOffset(numOffsets), info[axis].offset);\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexport { resolveOffsets };\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,aAAa,QAAQ,kBAAkB;AAC7D,SAASC,SAAS,QAAQ,eAAe;AACzC,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,aAAa,QAAQ,gBAAgB;AAE9C,MAAMC,KAAK,GAAG;EAAEC,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE;AAAE,CAAC;AAC5B,SAASC,cAAcA,CAACC,SAAS,EAAEC,IAAI,EAAEC,OAAO,EAAE;EAC9C,IAAI;IAAEC,MAAM,EAAEC,gBAAgB,GAAGV,YAAY,CAACW;EAAI,CAAC,GAAGH,OAAO;EAC7D,MAAM;IAAEI,MAAM,GAAGN,SAAS;IAAEO,IAAI,GAAG;EAAI,CAAC,GAAGL,OAAO;EAClD,MAAMM,WAAW,GAAGD,IAAI,KAAK,GAAG,GAAG,QAAQ,GAAG,OAAO;EACrD,MAAME,KAAK,GAAGH,MAAM,KAAKN,SAAS,GAAGP,SAAS,CAACa,MAAM,EAAEN,SAAS,CAAC,GAAGJ,KAAK;EACzE;AACJ;AACA;AACA;AACA;EACI,MAAMc,UAAU,GAAGJ,MAAM,KAAKN,SAAS,GACjC;IAAEW,KAAK,EAAEX,SAAS,CAACY,WAAW;IAAEC,MAAM,EAAEb,SAAS,CAACc;EAAa,CAAC,GAChE;IAAEH,KAAK,EAAEL,MAAM,CAACS,WAAW;IAAEF,MAAM,EAAEP,MAAM,CAACU;EAAa,CAAC;EAChE,MAAMC,aAAa,GAAG;IAClBN,KAAK,EAAEX,SAAS,CAACe,WAAW;IAC5BF,MAAM,EAAEb,SAAS,CAACgB;EACtB,CAAC;EACD;AACJ;AACA;AACA;EACIf,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAACe,MAAM,GAAG,CAAC;EAC5B;AACJ;AACA;AACA;EACI,IAAIC,UAAU,GAAG,CAAClB,IAAI,CAACM,IAAI,CAAC,CAAChB,WAAW;EACxC,MAAM6B,UAAU,GAAGhB,gBAAgB,CAACc,MAAM;EAC1C,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,UAAU,EAAEC,CAAC,EAAE,EAAE;IACjC,MAAMlB,MAAM,GAAGR,aAAa,CAACS,gBAAgB,CAACiB,CAAC,CAAC,EAAEJ,aAAa,CAACT,WAAW,CAAC,EAAEE,UAAU,CAACF,WAAW,CAAC,EAAEC,KAAK,CAACF,IAAI,CAAC,CAAC;IACnH,IAAI,CAACY,UAAU,IAAIhB,MAAM,KAAKF,IAAI,CAACM,IAAI,CAAC,CAACe,mBAAmB,CAACD,CAAC,CAAC,EAAE;MAC7DF,UAAU,GAAG,IAAI;IACrB;IACAlB,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAACkB,CAAC,CAAC,GAAGlB,MAAM;EACjC;EACA;AACJ;AACA;AACA;EACI,IAAIgB,UAAU,EAAE;IACZlB,IAAI,CAACM,IAAI,CAAC,CAAChB,WAAW,GAAGA,WAAW,CAACC,aAAa,CAAC4B,UAAU,CAAC,EAAEnB,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAAC;IAClFF,IAAI,CAACM,IAAI,CAAC,CAACe,mBAAmB,GAAG,CAAC,GAAGrB,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAAC;EAC3D;EACAF,IAAI,CAACM,IAAI,CAAC,CAACgB,QAAQ,GAAGtB,IAAI,CAACM,IAAI,CAAC,CAAChB,WAAW,CAACU,IAAI,CAACM,IAAI,CAAC,CAACiB,OAAO,CAAC;AACpE;AAEA,SAASzB,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}